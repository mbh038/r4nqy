<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Fisher’s Exact Test</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="fishers-exact-test_files/libs/clipboard/clipboard.min.js"></script>
<script src="fishers-exact-test_files/libs/quarto-html/quarto.js"></script>
<script src="fishers-exact-test_files/libs/quarto-html/popper.min.js"></script>
<script src="fishers-exact-test_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="fishers-exact-test_files/libs/quarto-html/anchor.min.js"></script>
<link href="fishers-exact-test_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="fishers-exact-test_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="fishers-exact-test_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="fishers-exact-test_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="fishers-exact-test_files/libs/bootstrap/bootstrap-c0367b04c37547644fece4185067e4a7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Fisher’s Exact Test</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Fisher’s Exact Test can be used in place of a chi-square test for independence in cases where counts are too low to make the chi-square approximation appropriate for calculating a <em>p</em>-value. A rule of thumb often used for this is that a chi-square test is no longer reliable when there are fewer than five or so counts in every cell of the contingency table.</p>
<p>Ronald Fisher devised an exact test now named after him that could be used for this scenario in situations where the marginal totals (ie row totals and column totals) of the table were fixed by the experimenter.</p>
<p>Say we were devising a phone app that we hoped could distingush between two visually similar species of grass given a photo. In an experiment, we show the app 10 cases of species A and 10 of species B and in each case we record the identification decision of the app. That will give four possibilities.</p>
<ul>
<li>species is A, app identifies it as A</li>
<li>species is A, app identifies it as B</li>
<li>species is B, app identifies is as B</li>
<li>species is B, app identifies it as A</li>
</ul>
<p>The counts of these decisions can be recorded in a two-way, in this case <span class="math inline">\(2 \times 2\)</span>, table, in which each cell contains the counts recorded for each combination of the levels of each factor. In a test run, suppose the numbers recorded for each case were as follows:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="fishers-exact-test_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Here we see that the row totals are set by the experimenter while the column totals are set by the app. Thus we see that the app is slightly more likely to choose A than B, regardless of the actual identity of the plant, since it went for A 11 times out of 20, and for B only 9 times.</p>
<p>Our <strong>null hypothesis</strong> might be:</p>
<p>The app has no ability to correctly distinguish species A from species B.</p>
<p>We should not use a chi-square test for independence here since the numbers in two of the cells are less than 5.</p>
<p>In the Fisher’s Exact Test, we accept that the marginal totals are as observed. With this constraint we then determine the probability of getting every possible table of cells, under the null hypothesis that the two factors are independent of each other. The <em>p</em>-value for (lack of) independence of the two variables is then the cumulative sum of the probabilities of getting the table we actually got, plus those of tables that are even less likely. That is just what <em>p</em>-values are - the probabiliy of gettting the data you got, or more extreme data, <em>if</em> the null hypothesis is true.</p>
<p>To do this, we notice that if the column and row totals have been fixed in advance, then only one of the cell values of the table is independent. We can choose any cell. Once this is known, all the others can be determined, using this first value and the marginal totals. It turns that we can treat this number as a random variable that varies with probabilities governed by the <strong>hypergeometric</strong> distribution. We can thus use this distribution to calculate the probability of getting any possible table, given the row and column totals.</p>
<p>Let’s see how this works.</p>
<section id="the-hypergeometric-function" class="level2">
<h2 class="anchored" data-anchor-id="the-hypergeometric-function">The Hypergeometric Function</h2>
<p>Imagine an urn with <em>N</em> balls, <em>K</em> of them white, the rest, <em>N</em>-<em>K</em> of them, black.</p>
<p>Draw a sample of <em>n</em> balls <em>without</em> replacement - that is, don’t put a ball back in the urn once it has been taken out.</p>
<p>Let <em>x</em> be the number of white balls in the sample.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="fishers-exact-test_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><em>x</em> is a random variable that follows a <em>hypergeometric</em> (<em>N</em>, <em>K</em>, <em>n</em>) distribution:</p>
<p><span class="math display">\[
\text{P}(X=x)=\frac{{K \choose x} {{N-K} \choose {N-x}}}{N\choose n}
\]</span></p>
<p>Here, terms like <span class="math inline">\(K\choose x\)</span> refer to the number of ways that <em>n</em> objects can be chosen from a collection of <em>N</em> objects. For details, see any book on proability, but the deatils need not concern us here. This tells us the probability that we will get <em>x</em> white balls if we draw <em>n</em> balls without replacement (each ball that is drawn is not put back) from an urn that at first contains <em>N</em> balls, <em>K</em> of them white.</p>
<p>For example, if we have an urn with <em>N</em> = 20 balls, <em>K</em> = 11 of them white, the remaining <em>N</em> - <em>K</em> = 9 of them black, and draw <em>n</em> = 10 balls without replacement, the probability that <em>x</em> = 7 of these will be white is given by</p>
<p><span class="math display">\[
\begin{align*}
N=20, K&amp;=11, n=10, x=7\\
\\
\text{P}(X=7)&amp; =\frac{{K \choose x} {{N-K} \choose {N-x}}}{N\choose n}\\
&amp;=\frac{{11 \choose 7} {{20-11} \choose {20-7}}}{20\choose 10}\\
&amp;= 0.014
\end{align*}
\]</span> Here, we calculated the probability of getting <span class="math inline">\(x\)</span> <em>given</em> the number <span class="math inline">\(K\)</span> of white balls in the urn, which is one column total of the table, the number <span class="math inline">\(n\)</span> of balls that were sampled, which is one row total, and the total number <span class="math inline">\(N\)</span> of balls in the urn. Given these three numbers we know the other column total, which must be <span class="math inline">\(N-K\)</span>, and the other row total which must be <span class="math inline">\(N-n\)</span>. These are the numbers of balls that were not sampled and the number of black balls in the urn, respectively.</p>
<p>Further, given that these row and column totals are all known, if we get <span class="math inline">\(x\)</span> white balls among the <span class="math inline">\(n\)</span> balls that we take from the urn, we also know the other three values in the table. That is we know the number of black balls that came out, and the numbers of white and black balls that must still be in the urn.</p>
<p>In other words, when we calculate the probability of getting a particular number <span class="math inline">\(x\)</span> of white balls from the urn, out of <span class="math inline">\(n\)</span> that we drew altogether, given that the urn contains <span class="math inline">\(K\)</span> white balls and <span class="math inline">\(N\)</span> balls altogether, we are calculating the probability of getting a particular set of four values in the <span class="math inline">\(2 \times 2\)</span> table.</p>
<p>Note too that when balls are sampled from the urn we do not preferentially sample white or black balls: we would expect the ratio of colours sampled to be roughly equal to the ratio of colours actually in the urn.</p>
<p>This is precisely the scenario for our app data under the null hypothesis of no association between the truth and the app’s decision. We know how many times it decided on Species A (ie we know one column total of our table, let’s call it <span class="math inline">\(K = 11\)</span>), we know how many seedlings of species A we actually had (so that’s one row total, let’s call it <span class="math inline">\(n = 10\)</span>) and we know how many seedlings we had altogether: <span class="math inline">\(N = 20\)</span>. Therefore, just as with the urn, we also know the other row and column totals, which must be 10 and 9 respectively. We find that the app decided on species A just 3 times. Convince yourself that knowing all these numbers means that the other entries in the table (top right, and the bottom row) are now also known.</p>
<p>Thus if we want to calculate the probability of getting precisely this table, that will be the same as the probability of deciding there were 3 white seedlings since that number fixes the other three entries in the table.</p>
<p>And finally, and more precisely, if we want to calculate the probability of our app getting this table of results <em>given</em> that its decision for any seedling is independenty of the truth for that seedling, then we have exactly the same set-up asfor the urn, and we can use the hypergeometric function to calculate the probability of getting any particular table of results.</p>
<p>In case you are worried, <em>we</em> will not normally use the hypergeometric function directly, nor de we even need to know it is being used. We can use the R runction <code>fisher.test()</code>: see below.</p>
</section>
<section id="hypergeometric-distribution-in-r" class="level2">
<h2 class="anchored" data-anchor-id="hypergeometric-distribution-in-r">Hypergeometric Distribution in R</h2>
<p>However if you are interested in the hypergeometric function, it is catered for in R like many other distributions by a family of four functions:</p>
<ul>
<li><code>dhyper(x, m, n, k)</code>.</li>
<li><code>phyper(q, m, n, k)</code>.</li>
<li><code>qhyper(p, m, n, k)</code>.</li>
<li><code>rhyper(nn, m, n, k)</code>.</li>
</ul>
<p>where, in R:</p>
<ul>
<li>m = number of white balls in urn<br>
</li>
<li>n = number of black balls in urn.</li>
<li>k = number of balls sampled (without replacement).</li>
<li>x = number of white balls in sample.</li>
<li>nn= number of balls in urn = m + n</li>
</ul>
<p>For further information on the use of any of these, type the name of the function preceded by a question mark into the console pane, bottom left. Help will then appear in the Help pane, bottom right.</p>
<p>In our example, to calculate the probability of a given table of results,</p>
<p>dhyper(r1c1, col1, nn-col1, row1)</p>
</section>
<section id="back-to-fishers-exact-test" class="level2">
<h2 class="anchored" data-anchor-id="back-to-fishers-exact-test">Back to Fisher’s Exact Test</h2>
<p>First we will go through all the steps manually just so you can see what is going on under the hood of a Fisher’s Exact Test, then we will do the test in R.</p>
<p>In this test we</p>
<ul>
<li>Assume the null hypothesis (independence) to be true.</li>
<li>Constrain the marginal counts to be as observed<br>
</li>
<li>Calculate the probability of the observed table, given the null hypothesis</li>
</ul>
<p>In the case of the example, that means that we should calculate</p>
<p><span class="math display">\[
P(\text{observed table}|H_0) = P(X=7|H_0)\\
X ∼ \text{Hypergeometric} (N=20, K=11, n=10)
\]</span> and then</p>
<ul>
<li>In the same way we calculate the probabilities of all possible tables, given the constraints of the marginal totals, then we</li>
<li>Sum the probabilities of all tables that are as or more ‘extreme’ than the observed table ie whose probability is less than or equal to that of the observed table.</li>
<li>The resulting sum is the <em>p</em>-value of the observed table, given the marginal totals.<br>
</li>
<li>If this <em>p</em>-value is less than a predetermined threshold value (the value chosen is usually 0.05) then we reject the null hypothesis and regard the data as providing evidence for an association between the factors. That is we reject the idea that they are independent of each other. In the case presented above, that means we reject the idea</li>
</ul>
<section id="example" class="level3">
<h3 class="anchored" data-anchor-id="example">Example</h3>
<p>In the figure below we show all possible tables, along with their respective <em>p</em>-values, calculate using the hypergeometric function. The table of the actual results obtained is picked out in colour. We see that tables</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="fishers-exact-test_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We see that tables a), b), c), h) (the actual results), i) and j) all have <em>p</em>-values equal to or less than that of the actual results. The combined total of these <em>p</em>-values is 0.06978.</p>
<p>This <em>p</em>-value is bigger than 0.05 so we would normally fail to reject the null hypothesis that there is no association between the two factors. There is no evidence from these data that the app does any better than guessing whether a plant is species A or species B!</p>
</section>
</section>
<section id="fishers-exact-test-in-r" class="level2">
<h2 class="anchored" data-anchor-id="fishers-exact-test-in-r">Fisher’s Exact Test in R</h2>
<p>If we already know the four counts for our <span class="math inline">\(2 \times 2\)</span> table we can create a <span class="math inline">\(2 \times 2\)</span> matrix of them like this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>app.mat <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">8</span>,<span class="dv">7</span>,<span class="dv">2</span>), <span class="at">nrow =</span> <span class="dv">2</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>app.mat</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2]
[1,]    3    7
[2,]    8    2</code></pre>
</div>
</div>
<p>If we had the data in a tidy data frame like we had for the ladybird data we can convert it into a matrix using the <code>xtabs()</code> command in the same way as we did there.</p>
<p>We use this matrix as the argument of the <code>fisher.test()</code> function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fisher.test</span>(app.mat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Fisher's Exact Test for Count Data

data:  app.mat
p-value = 0.06978
alternative hypothesis: true odds ratio is not equal to 1
95 percent confidence interval:
 0.007870555 1.133635839
sample estimates:
odds ratio 
 0.1226533 </code></pre>
</div>
</div>
<p>That’s it! It’s a one liner, just like many statistical tests in R. You will see that this gives the same <em>p</em>-value that we have calculated manually.</p>
</section>
<section id="what-if-we-just-use-a-chi-square-test" class="level2">
<h2 class="anchored" data-anchor-id="what-if-we-just-use-a-chi-square-test">What if we just use a chi-square test?</h2>
<p>If we use a chi-square test on this same data, R gives us a warning, because of the low values in the table:</p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Warning in stats::chisq.test(x, y, ...): Chi-squared approximation may be
incorrect</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Pearson's Chi-squared test with Yates' continuity correction

data:  app.mat
X-squared = 3.2323, df = 1, p-value = 0.0722</code></pre>
</div>
</div>
<p>This is a cautionary tale: you can use R to run this or that test on data even when the data are unsuitable for the test, and you will get an output, but the output may not be reliable. Here, at least, we are given a warning that alerts us to this possibility, and in fact our conclusion would be the same as it was when using the Fisher’s Exact Test, but that is not always the case. You need to think carefully as to whether a given test is the right one <em>before</em> you use it.</p>
</section>
<section id="why-not-always-use-fishers-exact-test-instead-of-a-chi-square-test" class="level2">
<h2 class="anchored" data-anchor-id="why-not-always-use-fishers-exact-test-instead-of-a-chi-square-test">Why not always use Fisher’s Exact Test instead of a chi-square test?</h2>
<p>Fisher’s Exact Test becomes computationally expensive when the number of tables for which a <em>p</em>-value has to be calculated becomes very large. This happens very quickly when each of the two factors has more than two levels, so that the contingency table is no longer <span class="math inline">\(2 \times 2\)</span> but <span class="math inline">\(3 \times 4\)</span> or <span class="math inline">\(4\times 6\)</span> and so on. However for <span class="math inline">\(2 \times 2\)</span> tables it works well and quickly for table cell values into the 1000s and is a perfectly valid alternative to the chi-squared test. But then, in that case, why not just use a chi-squared test? For large cell values this works well and anyone reading your work is more likely to be familiar with it than with the Fisher’s Exact Test.</p>
</section>
<section id="another-cautionary-note" class="level2">
<h2 class="anchored" data-anchor-id="another-cautionary-note">Another Cautionary Note</h2>
<p>This leads us to think that the Fisher’s Exact Test is only really a better alternative to the chi-squared test when sample sizes are very small and the chi-squared approximation becomes invalid. However, think about it. If you have a small sample then it is likely that it is not very representative of the population from which it has been drawn, and that you will fail to detect any association that there may be between the two factors. The solution therefore, when you have a small sample, is likely not to say Hallelujah! and grasp the Fisher’s Test with glee, but, if you can, to get a bigger sample. However, if that is not possible and you are stuck with a small sample size, then a Fisher’s Exact Test of independence is more reliable than a chi-squared test.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>